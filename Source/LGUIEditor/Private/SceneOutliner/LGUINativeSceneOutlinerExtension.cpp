// Copyright 2019-2021 LexLiu. All Rights Reserved.

#include "SceneOutliner/LGUINativeSceneOutlinerExtension.h"
#include "LGUIEditorModule.h"
#include "Editor.h"
#include "LevelEditor.h"
#include "Widgets/Docking/SDockTab.h"
#include "Widgets/Views/STreeView.h"
#include "ISceneOutliner.h"
#include "ITreeItem.h"
#include "ActorTreeItem.h"
#include "FolderTreeItem.h"
#include "WorldTreeItem.h"
#include "JsonObjectConverter.h"
#include "SceneOutlinerStandaloneTypes.h"
#include "EditorActorFolders.h"

bool ULGUINativeSceneOutlinerExtension::active = true;

void ULGUINativeSceneOutlinerExtension::Init()
{
	FEditorDelegates::PreSaveWorld.AddUObject(this, &ULGUINativeSceneOutlinerExtension::OnPreSaveWorld);
	FEditorDelegates::OnMapOpened.AddUObject(this, &ULGUINativeSceneOutlinerExtension::OnMapOpened);
	FEditorDelegates::PreBeginPIE.AddUObject(this, &ULGUINativeSceneOutlinerExtension::OnPreBeginPIE);
	FEditorDelegates::BeginPIE.AddUObject(this, &ULGUINativeSceneOutlinerExtension::OnBeginPIE);
	FEditorDelegates::EndPIE.AddUObject(this, &ULGUINativeSceneOutlinerExtension::OnEndPIE);
}
void ULGUINativeSceneOutlinerExtension::Tick(float DeltaTime)
{
	if (needToRestore)
	{
		if (frameCount < 2)
		{
			RestoreSceneOutlinerState();
		}
		else
		{
			frameCount = 0;
			needToRestore = false;
		}
		frameCount++;
	}
}
TStatId ULGUINativeSceneOutlinerExtension::GetStatId() const
{
	RETURN_QUICK_DECLARE_CYCLE_STAT(ULGUIEditorManagerObject, STATGROUP_Tickables);
}

void ULGUINativeSceneOutlinerExtension::OnPreSaveWorld(uint32 SaveFlags, UWorld* World)
{
	SaveSceneOutlinerState();
	//save to file
	static FString readmeString = TEXT("This file is generated by LGUI Editor, used to restore SceneOutliner actor's folder state, only valid for editor");
	static FString readmeStringCH = TEXT("此文件是LGUI编辑器自动生成的，用来还原场景中的Actor层级的打开和关闭的状态，只在编辑器里用");
	SceneOutlinerStateStruct.readme = readmeString;
	SceneOutlinerStateStruct.readmeCH = readmeStringCH;
	auto worldPathName = World->GetPathName();
	auto& arrayValue = SceneOutlinerStateStruct.WorldNameToUnexpandedActor.FindOrAdd(worldPathName);
	arrayValue.ExpandedFolderArray = ExpandedFolderArray;
	arrayValue.UnexpandedActorArray = UnexpandedActorArray;
	arrayValue.TemporarilyHiddenInEditorActorArray = TemporarilyHiddenInEditorActorArray;
	FString jsonStr;
	FJsonObjectConverter::UStructToJsonObjectString(SceneOutlinerStateStruct, jsonStr);
	FFileHelper::SaveStringToFile(jsonStr, *GetLGUIDataFilePath());
}
void ULGUINativeSceneOutlinerExtension::OnMapOpened(const FString& FileName, bool AsTemplate)
{
	//load from file
	FString jsonStr;
	FFileHelper::LoadFileToString(jsonStr, *GetLGUIDataFilePath());
	FJsonObjectConverter::JsonObjectStringToUStruct(jsonStr, &SceneOutlinerStateStruct, 0, 0);
	auto worldPathName = GEditor->GetEditorWorldContext().World()->GetPathName();
	if (auto arrayPtr = SceneOutlinerStateStruct.WorldNameToUnexpandedActor.Find(worldPathName))
	{
		ExpandedFolderArray = arrayPtr->ExpandedFolderArray;
		UnexpandedActorArray = arrayPtr->UnexpandedActorArray;
		TemporarilyHiddenInEditorActorArray = arrayPtr->TemporarilyHiddenInEditorActorArray;
	}
	else
	{
		ExpandedFolderArray.Empty();
		UnexpandedActorArray.Empty();
		TemporarilyHiddenInEditorActorArray.Empty();
	}

	SetDelayRestore(true);
}
const FString& ULGUINativeSceneOutlinerExtension::GetLGUIDataFilePath()
{
	static FString jsonFilePath = FPaths::Combine(FPaths::ProjectIntermediateDir(), TEXT("LGUI_Saved_Data.json"));
	return jsonFilePath;
}
void ULGUINativeSceneOutlinerExtension::OnPreBeginPIE(const bool IsSimulating)
{
	//SaveSceneOutlinerState();
}
void ULGUINativeSceneOutlinerExtension::OnBeginPIE(const bool IsSimulating)
{
	SetDelayRestore(false);
}
void ULGUINativeSceneOutlinerExtension::OnEndPIE(const bool IsSimulating)
{
	SetDelayRestore(true);
}
void ULGUINativeSceneOutlinerExtension::SetDelayRestore(bool RestoreTemporarilyHidden)
{
	shouldRestoreTemporarilyHidden = RestoreTemporarilyHidden;
	needToRestore = true;
	frameCount = 0;
}

void ULGUINativeSceneOutlinerExtension::SaveSceneOutlinerState()
{
	if (!active)return;
	FLevelEditorModule& LevelEditorModule = FModuleManager::GetModuleChecked<FLevelEditorModule>(TEXT("LevelEditor"));
	TSharedPtr<FTabManager> LevelEditorTabManager = LevelEditorModule.GetLevelEditorTabManager();
	ExpandedFolderArray.Reset();
	TArray<AActor*> ExpandedActorArray;
	if (LevelEditorTabManager.IsValid())
	{
		TSharedPtr<SDockTab> SceneOutlinerTab = LevelEditorTabManager->FindExistingLiveTab(FTabId("LevelEditorSceneOutliner"));
		if (SceneOutlinerTab.IsValid())
		{
			auto BorderWidget = StaticCastSharedRef<SBorder>(SceneOutlinerTab->GetContent());
			auto SceneOutlinerWidget = StaticCastSharedRef<ISceneOutliner>(BorderWidget->GetContent());
			const auto& TreeView = SceneOutlinerWidget->GetTree();
			TSet<SceneOutliner::FTreeItemPtr> VisitingItems;
			TreeView.GetExpandedItems(VisitingItems);
			for (SceneOutliner::FTreeItemPtr& Item : VisitingItems)
			{
				switch (Item->GetTypeSortPriority())
				{
				default:
				case SceneOutliner::ETreeItemSortOrder::Actor:
				{
					TSharedPtr<SceneOutliner::FActorTreeItem> ActorTreeItem = StaticCastSharedPtr<SceneOutliner::FActorTreeItem>(Item);
					if (ActorTreeItem.IsValid() && ActorTreeItem->Actor.IsValid())
					{
						ExpandedActorArray.Add(ActorTreeItem->Actor.Get());
					}
				}
				break;
				case SceneOutliner::ETreeItemSortOrder::Folder:
				{
					TSharedPtr<SceneOutliner::FFolderTreeItem> FolderTreeItem = StaticCastSharedPtr<SceneOutliner::FFolderTreeItem>(Item);
					if (FolderTreeItem.IsValid())
					{
						ExpandedFolderArray.Add(FolderTreeItem->Path);
					}
				}
				break;
				case SceneOutliner::ETreeItemSortOrder::World:
				{
					TSharedPtr<SceneOutliner::FWorldTreeItem> WorldTreeItem = StaticCastSharedPtr<SceneOutliner::FWorldTreeItem>(Item);
					if (WorldTreeItem.IsValid() && WorldTreeItem->World.IsValid())
					{
						ExpandedFolderArray.Add(WorldTreeItem->World->GetFName());
					}
				}
				break;
				}
			}
		}
	}
	TemporarilyHiddenInEditorActorArray.Reset();
	UnexpandedActorArray.Reset();
	if (auto world = GEditor->GetEditorWorldContext().World())
	{
		for (TActorIterator<AActor> ActorItr(world); ActorItr; ++ActorItr)
		{
			if(!IsValid(*ActorItr))continue;
			if (!ExpandedActorArray.Contains(*ActorItr))
			{
				UnexpandedActorArray.Add((*ActorItr)->GetFName());
			}
			if ((*ActorItr)->IsTemporarilyHiddenInEditor())
			{
				TemporarilyHiddenInEditorActorArray.Add((*ActorItr)->GetFName());
			}
		}
	}
}
//ALGUIEditorLevelDataStorageActor* ULGUINativeSceneOutlinerExtension::FindOrCreateDataStorageActor()
//{
//	ALGUIEditorLevelDataStorageActor* result = nullptr;
//	if (auto world = GEditor->GetEditorWorldContext().World())
//	{
//		for (TActorIterator<ALGUIEditorLevelDataStorageActor> ActorItr(world); ActorItr; ++ActorItr)
//		{
//			if (!IsValid(*ActorItr))continue;
//			result = *ActorItr;
//			break;
//		}
//		if (!result)
//		{
//			result = world->SpawnActor<ALGUIEditorLevelDataStorageActor>();
//		}
//	}
//	return result;
//}

void ULGUINativeSceneOutlinerExtension::RestoreSceneOutlinerStateForTreeItem(SceneOutliner::FTreeItemPtr& Item)
{
	switch (Item->GetTypeSortPriority())
	{
	default:
	case SceneOutliner::ETreeItemSortOrder::Actor:
	{
		TSharedPtr<SceneOutliner::FActorTreeItem> ActorTreeItem = StaticCastSharedPtr<SceneOutliner::FActorTreeItem>(Item);
		if (ActorTreeItem.IsValid() && ActorTreeItem->Actor.IsValid())
		{
			//expend
			bool needToExpand = !UnexpandedActorArray.Contains(ActorTreeItem->Actor->GetFName());
			ActorTreeItem->Flags.bIsExpanded = needToExpand;
		}
	}
	break;
	case SceneOutliner::ETreeItemSortOrder::Folder:
	{
		TSharedPtr<SceneOutliner::FFolderTreeItem> FolderTreeItem = StaticCastSharedPtr<SceneOutliner::FFolderTreeItem>(Item);
		if (FolderTreeItem.IsValid())
		{
			//expend
			bool needToExpand = ExpandedFolderArray.Contains(FolderTreeItem->Path);
			FolderTreeItem->Flags.bIsExpanded = needToExpand;
		}
	}
	break;
	case SceneOutliner::ETreeItemSortOrder::World:
	{
		TSharedPtr<SceneOutliner::FWorldTreeItem> WorldTreeItem = StaticCastSharedPtr<SceneOutliner::FWorldTreeItem>(Item);
		if (WorldTreeItem.IsValid() && WorldTreeItem->World.IsValid())
		{
			//expend
			bool needToExpand = ExpandedFolderArray.Contains(WorldTreeItem->World->GetFName());
			WorldTreeItem->Flags.bIsExpanded = needToExpand;
		}
	}
	break;
	}
}

void ULGUINativeSceneOutlinerExtension::RestoreSceneOutlinerState()
{
	if (!active)return;
	FLevelEditorModule& LevelEditorModule = FModuleManager::GetModuleChecked<FLevelEditorModule>(TEXT("LevelEditor"));
	TSharedPtr<FTabManager> LevelEditorTabManager = LevelEditorModule.GetLevelEditorTabManager();
	if (LevelEditorTabManager.IsValid())
	{
		//if (FActorFolders::IsAvailable())
		//{
		//	auto folderProperties = FActorFolders::Get().GetFolderPropertiesForWorld(*GEditor->GetEditorWorldContext().World());
		//	for (auto keyValue : folderProperties)
		//	{
		//		UE_LOG(LogTemp, Error, TEXT("Folder:%s, expand:%d"), *(keyValue.Key.ToString()), keyValue.Value.bIsExpanded);
		//		auto folderProperty = FActorFolders::Get().GetFolderProperties(*GEditor->GetEditorWorldContext().World(), keyValue.Key);
		//		folderProperty->bIsExpanded = true;
		//	}
		//	GEditor->BroadcastLevelActorListChanged();
		//}
		TSharedPtr<SDockTab> SceneOutlinerTab = LevelEditorTabManager->FindExistingLiveTab(FTabId("LevelEditorSceneOutliner"));
		if (SceneOutlinerTab.IsValid())
		{
			auto BorderWidget = StaticCastSharedRef<SBorder>(SceneOutlinerTab->GetContent());
			auto SceneOutlinerWidget = StaticCastSharedRef<ISceneOutliner>(BorderWidget->GetContent());
			auto& TreeView = SceneOutlinerWidget->GetTree();
			TSet<SceneOutliner::FTreeItemPtr> VisitingItems;
			TreeView.GetExpandedItems(VisitingItems);
			for (SceneOutliner::FTreeItemPtr& Item : VisitingItems)
			{
				RestoreSceneOutlinerStateForTreeItem(Item);
			}
			GEditor->BroadcastLevelActorListChanged();
		}
	}
	if (shouldRestoreTemporarilyHidden)
	{
		//hidden
		if (auto world = GEditor->GetEditorWorldContext().World())
		{
			for (TActorIterator<AActor> ActorItr(world); ActorItr; ++ActorItr)
			{
				if (!IsValid(*ActorItr))continue;
				if (TemporarilyHiddenInEditorActorArray.Contains((*ActorItr)->GetFName()))
				{
					(*ActorItr)->SetIsTemporarilyHiddenInEditor(true);
				}
			}
		}
	}
}
